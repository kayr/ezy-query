package io.github.kayr.ezyquery.gen;

import com.squareup.javapoet.*;
import io.github.kayr.ezyquery.parser.QueryAndParams;
import io.github.kayr.ezyquery.parser.SqlParts;
import io.github.kayr.ezyquery.sql.Zql;
import io.github.kayr.ezyquery.util.Elf;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.lang.model.element.Modifier;

@lombok.RequiredArgsConstructor(staticName = "of")
public class StaticQueryGen implements WritesCode {

  @lombok.SneakyThrows
  @Override
  public Path writeTo(Path path) {
    return javaFile().writeToPath(path, StandardCharsets.UTF_8);
  }

  private final String packageName;
  private final String mainClassName;
  private final String sql;

  public JavaFile javaFile() {

    List<SectionsParser.Section> sections = SectionsParser.splitUp(sql);

    Elf.assertTrue(
        !sections.isEmpty(), "No sections found in the sql file. Please check the file format.");

    List<TypeSpec> cInnerClasses =
        sections.stream().map(this::createSectionClass).collect(Collectors.toList());

    List<MethodSpec> mSections = new ArrayList<>();
    for (TypeSpec section : cInnerClasses) {
      String methodName = StringCaseUtil.toCamelCase(section.name);
      mSections.add(
          MethodSpec.methodBuilder(methodName)
              .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
              .returns(ClassName.get(packageName, mainClassName, section.name))
              .addStatement("return new $N()", section)
              .build());
    }

    TypeSpec cMainClass =
        TypeSpec.classBuilder(ClassName.get(packageName, mainClassName))
            .addModifiers(Modifier.PUBLIC)
            .addJavadoc("Generated by EzyQuery\n")
            .addAnnotation(
                AnnotationSpec.builder(CodeElf.resolveGeneratedAnnotation())
                    .addMember("value", "$S", StaticQueryGen.class.getName())
                    .addMember("date", "$S", TimeElf.nowStr())
                    .build())
            .addTypes(cInnerClasses)
            .addMethods(mSections)
            .build();

    return JavaFile.builder(packageName, cMainClass).build();
  }

  private TypeSpec createSectionClass(SectionsParser.Section section) {
    String name = StringCaseUtil.toPascalCase(section.name());
    SqlParts sqlParts = SqlParts.of(section.sql().trim());

    ClassName className = ClassName.get(packageName, mainClassName, name);

    FieldSpec.Builder fSqlField =
        FieldSpec.builder(SqlParts.class, "sql", Modifier.PRIVATE, Modifier.FINAL);

    MethodSpec mDefaultConstructor =
        CodeElf.publicMethod("<init>", TypeName.VOID)
            .addModifiers(Modifier.PUBLIC)
            .addCode("this.sql = ")
            .addCode(CodeElf.buildSqlParts(sqlParts).build())
            .addCode(";")
            .build();

    MethodSpec mConstructor =
        MethodSpec.methodBuilder("<init>")
            .addModifiers(Modifier.PRIVATE)
            .addParameter(SqlParts.class, "sql")
            .addStatement("this.sql = sql")
            .build();

    List<MethodSpec> mSetMethods = methodsForSet(sqlParts, className);

    MethodSpec mGetQuery =
        CodeElf.publicMethod("getQuery", QueryAndParams.class)
            .addStatement("return sql.getQuery()")
            .build();

    MethodSpec mGetSql =
        CodeElf.publicMethod("getSql", String.class, Override.class)
            .addStatement("return getQuery().getSql()")
            .build();

    MethodSpec mGetParams =
        CodeElf.publicMethod(
                "getParams", CodeElf.paramType(List.class, Object.class), Override.class)
            .addStatement("return getQuery().getParams()")
            .build();

    return TypeSpec.classBuilder(className)
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addSuperinterface(Zql.Query.class)
        .addJavadoc("-- $L\n", section.name())
        .addJavadoc(section.sql().trim())
        .addField(fSqlField.build())
        .addMethod(mDefaultConstructor)
        .addMethod(mConstructor)
        .addMethods(mSetMethods)
        .addMethod(mGetQuery)
        .addMethod(mGetSql)
        .addMethod(mGetParams)
        .build();
  }

  private static List<MethodSpec> methodsForSet(SqlParts sqlParts, ClassName className) {
    List<MethodSpec> setMethods = new ArrayList<>();

    List<SqlParts.IPart> parts = sqlParts.getParts();
    for (SqlParts.IPart part : parts) {
      if (part instanceof SqlParts.IPart.Param) {
        SqlParts.IPart.Param paramPart = (SqlParts.IPart.Param) part;
        String methodName = StringCaseUtil.toCamelCase(paramPart.asString());

        MethodSpec setMethod =
            CodeElf.publicMethod(methodName, className)
                .addParameter(Object.class, methodName)
                .addStatement(
                    "return new $T(sql.setParam($S, $L))", className, methodName, methodName)
                .build();

        setMethods.add(setMethod);
      }
    }
    return setMethods;
  }
}

/*
#fileName = Cars.static.sql
-- select cars
select name, model, year from cars where id = :id and year = :year

-- select cars by year
select name, model, year from cars where year = :year

will generate

public class Cars{

  public static class SelectCars {

  private final SqlParts sql = SqlParts.of(
      SqlParts.text("select name, model, year from cars where id = ),
      SqlParts.paramPart("id"),
       SqlParts.text(" and year = "),
      SqlParts.paramPart("year")
  );


  public SelectCars() {
  }

  private SelectCars(SqlParts sql) {
    this.params = new HashMap<>(other.params);
  }

  public Car id(Object id){
    return new SelectCars(sql.setParam("id",id));
  }

    public Car year(Object year){
        return new SelectCars(sql.setParam("year",year));
    }

    public QueryAndParams getQuery(){
        return sql.getQuery();
    }

    public SelectCars setParam(Field field, Object value){
        return new SelectCars(sql.setParam(field.getName(),value));
    }

    public SelectCars setParams(Map<String, Object> params){
        SqlParts sql = this.sql;
        for (Map.Entry<String, Object> entry : params.entrySet()) {
           sql = sql.setParam(entry.getKey(), entry.getValue());
        }
        return new SelectCars(sql);

    }


}


 */
