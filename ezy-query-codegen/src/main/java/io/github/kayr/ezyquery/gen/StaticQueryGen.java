package io.github.kayr.ezyquery.gen;

import com.squareup.javapoet.*;
import io.github.kayr.ezyquery.parser.QueryAndParams;
import io.github.kayr.ezyquery.parser.SqlParts;
import io.github.kayr.ezyquery.util.Elf;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;
import javax.lang.model.element.Modifier;

@lombok.RequiredArgsConstructor(access = lombok.AccessLevel.PRIVATE)
public class StaticQueryGen implements WritesCode {

  @lombok.SneakyThrows
  @Override
  public Path writeTo(Path path) {
    return javaFile().writeToPath(path, StandardCharsets.UTF_8);
  }

  private final String packageName;
  private final String mainClassName;
  private final String sql;
  private final CodeStyle style;

  public static StaticQueryGen of(String packageName, String mainClassName, String sql) {
    return of(packageName, mainClassName, sql, false);
  }

  public static StaticQueryGen of(
      String packageName, String mainClassName, String sql, boolean mutable) {
    return new StaticQueryGen(
        packageName, mainClassName, sql, mutable ? new MutableStyle() : new ImmutableStyle());
  }

  public JavaFile javaFile() {

    List<SectionsParser.Section> sections = SectionsParser.splitUp(sql);

    Elf.assertTrue(
        !sections.isEmpty(), "No sections found in the sql file. Please check the file format.");

    List<TypeSpec> cInnerClasses =
        sections.stream().map(this::createSectionClass).collect(Collectors.toList());

    List<MethodSpec> mSections = new ArrayList<>();
    for (TypeSpec section : cInnerClasses) {
      String methodName = StringCaseUtil.toCamelCase(section.name);
      mSections.add(
          MethodSpec.methodBuilder(methodName)
              .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
              .returns(ClassName.get(packageName, mainClassName, section.name))
              .addStatement("return new $N()", section)
              .build());
    }

    TypeSpec cMainClass =
        TypeSpec.classBuilder(ClassName.get(packageName, mainClassName))
            .addModifiers(Modifier.PUBLIC)
            .addJavadoc("Generated by EzyQuery\n")
            .addAnnotation(
                AnnotationSpec.builder(CodeElf.resolveGeneratedAnnotation())
                    .addMember("value", "$S", StaticQueryGen.class.getName())
                    .addMember("date", "$S", TimeElf.nowStr())
                    .build())
            .addTypes(cInnerClasses)
            .addMethods(mSections)
            .build();

    return JavaFile.builder(packageName, cMainClass).build();
  }

  TypeSpec createSectionClass(SectionsParser.Section section) {
    return createSectionClass(section.name(), section.sql());
  }

  TypeSpec createSectionClass(String sectionName, String sql) {
    String theClassName = StringCaseUtil.toPascalCase(sectionName);
    SqlParts sqlParts = SqlParts.of(sql.trim());

    ClassName className = ClassName.get(packageName, mainClassName, theClassName);

    FieldSpec.Builder fSqlField = FieldSpec.builder(SqlParts.class, "sql", Modifier.PRIVATE);
    style.applySqlFieldModifiers(fSqlField);

    MethodSpec mDefaultConstructor =
        CodeElf.publicMethod("<init>", TypeName.VOID)
            .addModifiers(Modifier.PUBLIC)
            .addCode("this.sql = ")
            .addCode(CodeElf.buildSqlParts(sqlParts).build())
            .addCode(";")
            .build();

    MethodSpec mConstructor =
        MethodSpec.methodBuilder("<init>")
            .addModifiers(Modifier.PRIVATE)
            .addParameter(SqlParts.class, "sql")
            .addStatement("this.sql = sql")
            .build();

    List<MethodSpec> mSetMethods = methodsForSet(sqlParts, className);

    MethodSpec mGetQuery =
        CodeElf.publicMethod("getQuery", QueryAndParams.class)
            .addStatement("return sql.getQuery()")
            .build();

    MethodSpec.Builder mSetParamBuilder =
        CodeElf.publicMethod("setParam", className)
            .addParameter(String.class, "param")
            .addParameter(Object.class, "value");

    style.applySetParamBody(mSetParamBuilder, className);
    MethodSpec mSetParam = mSetParamBuilder.build();

    MethodSpec.Builder mSetParamsBuilder =
        CodeElf.publicMethod("setParams", className)
            .addParameter(CodeElf.paramType(Map.class, String.class, Object.class), "params")
            .addStatement("SqlParts sql = this.sql")
            .beginControlFlow("for (Map.Entry<String, Object> entry : params.entrySet())")
            .addStatement("sql = sql.setParam(entry.getKey(), entry.getValue())")
            .endControlFlow();

    style.applySetParamsBody(mSetParamsBuilder, className);
    MethodSpec mSetParams = mSetParamsBuilder.build();

    return TypeSpec.classBuilder(className)
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addJavadoc("-- $L\n", sectionName)
        .addJavadoc(sql.trim())
        .addField(fSqlField.build())
        .addMethod(mDefaultConstructor)
        .addMethod(mConstructor)
        .addMethods(mSetMethods)
        .addMethod(mGetQuery)
        .addMethod(mSetParam)
        .addMethod(mSetParams)
        .build();
  }

  private List<MethodSpec> methodsForSet(SqlParts sqlParts, ClassName className) {
    Set<MethodSpec> setMethods = new LinkedHashSet<>(); // use a set to avoid duplicates

    List<SqlParts.IPart> parts = sqlParts.getParts();
    for (SqlParts.IPart part : parts) {
      if (part instanceof SqlParts.IPart.Param) {
        SqlParts.IPart.Param paramPart = (SqlParts.IPart.Param) part;
        String methodName = StringCaseUtil.toCamelCase(paramPart.asString());

        MethodSpec.Builder setMethodBuilder =
            CodeElf.publicMethod(methodName, className).addParameter(Object.class, methodName);

        style.applyParamSetterBody(setMethodBuilder, className, paramPart.asString(), methodName);

        setMethods.add(setMethodBuilder.build());
      }
    }
    return new ArrayList<>(setMethods);
  }

  interface CodeStyle {
    void applySqlFieldModifiers(FieldSpec.Builder builder);

    void applySetParamBody(MethodSpec.Builder builder, ClassName className);

    void applySetParamsBody(MethodSpec.Builder builder, ClassName className);

    void applyParamSetterBody(
        MethodSpec.Builder builder, ClassName className, String paramName, String argName);
  }

  static class MutableStyle implements CodeStyle {
    @Override
    public void applySqlFieldModifiers(FieldSpec.Builder builder) {}

    @Override
    public void applySetParamBody(MethodSpec.Builder builder, ClassName className) {
      builder.addStatement("this.sql = sql.setParam(param, value)").addStatement("return this");
    }

    @Override
    public void applySetParamsBody(MethodSpec.Builder builder, ClassName className) {
      builder.addStatement("this.sql = sql").addStatement("return this");
    }

    @Override
    public void applyParamSetterBody(
        MethodSpec.Builder builder, ClassName className, String paramName, String argName) {
      builder
          .addStatement("this.sql = sql.setParam($S, $L)", paramName, argName)
          .addStatement("return this");
    }
  }

  static class ImmutableStyle implements CodeStyle {
    @Override
    public void applySqlFieldModifiers(FieldSpec.Builder builder) {
      builder.addModifiers(Modifier.FINAL);
    }

    @Override
    public void applySetParamBody(MethodSpec.Builder builder, ClassName className) {
      builder.addStatement("return new $T(sql.setParam(param, value))", className);
    }

    @Override
    public void applySetParamsBody(MethodSpec.Builder builder, ClassName className) {
      builder.addStatement("return new $T(sql)", className);
    }

    @Override
    public void applyParamSetterBody(
        MethodSpec.Builder builder, ClassName className, String paramName, String argName) {
      builder.addStatement("return new $T(sql.setParam($S, $L))", className, paramName, argName);
    }
  }
}

/*
#fileName = Cars.static.sql
-- select cars
select name, model, year from cars where id = :id and year = :year

-- select cars by year
select name, model, year from cars where year = :year

will generate

public class Cars{

  public static class SelectCars {

  private final SqlParts sql = SqlParts.of(
      SqlParts.text("select name, model, year from cars where id = ),
      SqlParts.paramPart("id"),
       SqlParts.text(" and year = "),
      SqlParts.paramPart("year")
  );


  public SelectCars() {
  }

  private SelectCars(SqlParts sql) {
    this.params = new HashMap<>(other.params);
  }

  public Car id(Object id){
    return new SelectCars(sql.setParam("id",id));
  }

    public Car year(Object year){
        return new SelectCars(sql.setParam("year",year));
    }

    public QueryAndParams getQuery(){
        return sql.getQuery();
    }

    public SelectCars setParam(Field field, Object value){
        return new SelectCars(sql.setParam(field.getName(),value));
    }

    public SelectCars setParams(Map<String, Object> params){
        SqlParts sql = this.sql;
        for (Map.Entry<String, Object> entry : params.entrySet()) {
           sql = sql.setParam(entry.getKey(), entry.getValue());
        }
        return new SelectCars(sql);

    }


}


 */
